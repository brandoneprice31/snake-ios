{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf110
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red92\green38\blue153;
\red63\green110\blue116;\red28\green0\blue207;\red46\green13\blue110;\red196\green26\blue22;\red38\green71\blue75;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 //\
//  GameScene.swift\
//  Snake\
//\
//  Created by Brandon Price on 8/20/15.\
//  Copyright (c) 2015 Brandon Price. All rights reserved.\
//\
\cf0 \
\cf3 import\cf0  SpriteKit\
\
\cf3 class\cf0  HowToPlayScene: \cf4 SKScene\cf0  \{\
    \
    \cf2 // MARK: - Set Up Constants\
\cf0     \cf3 var\cf0  xMax = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  yMax = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  xMin = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  yMin = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  xMid = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  yMid = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  Width = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  Height = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  BlockArray = [\cf5 Block\cf0 ]()\
    \cf3 var\cf0  BlockHeight = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  BlockWidth = \cf4 CGFloat\cf0 ()\
    \cf3 var\cf0  Direction = \cf4 String\cf0 ()\
    \cf3 var\cf0  SnakeTimer = \cf4 NSTimer\cf0 ()\
    \cf3 var\cf0  FoodBlock = \cf5 Food\cf0 (Coordinate: \cf4 CGPoint\cf0 (x:\cf6 0\cf0 ,y:\cf6 0\cf0 ))\
    \cf3 var\cf0  StartPoint = \cf4 CGPoint\cf0 ()\
    \cf3 var\cf0  EndPoint = \cf4 CGPoint\cf0 ()\
    \cf3 var\cf0  OpenSpaces = [\cf4 CGPoint\cf0 ]()\
    \cf3 var\cf0  PreviousDirection = \cf4 String\cf0 ()\
    \cf3 var\cf0  Circle = \cf4 SKShapeNode\cf0 ()\
    \cf3 var\cf0  TutorialInt = \cf4 Int\cf0 ()\
    \cf3 var\cf0  DirectionArray = [\cf4 String\cf0 ]()\
    \cf3 var\cf0  Label = \cf4 SKLabelNode\cf0 ()\
    \cf3 var\cf0  LabelArray = [\cf4 String\cf0 ]()\
    \cf3 var\cf0  WordsInt = \cf4 Int\cf0 ()\
    \cf3 var\cf0  NoFoodYet = \cf4 Bool\cf0 ()\
    \cf3 var\cf0  MainMenuButton = \cf4 SKSpriteNode\cf0 ()\
    \cf3 var\cf0  MainMenuLabel = \cf4 SKLabelNode\cf0 ()\
    \cf3 var\cf0  PlayAgainButton = \cf4 SKSpriteNode\cf0 ()\
    \cf3 var\cf0  PlayAgainLabel = \cf4 SKLabelNode\cf0 ()\
    \cf3 var\cf0  ReadyToPlay = \cf4 Bool\cf0 ()\
    \cf3 var\cf0  WordsTutorialTimer = \cf4 NSTimer\cf0 ()\
    \cf3 var\cf0  QuitButton = \cf4 SKSpriteNode\cf0 ()\
    \cf3 var\cf0  QuitLabel = \cf4 SKLabelNode\cf0 ()\
    \cf3 var\cf0  QuitButtonClicked = \cf4 Bool\cf0 ()\
    \cf3 var\cf0  MoveMentTutorialTimer = \cf4 NSTimer\cf0 ()\
    \
    \cf3 override\cf0  \cf3 func\cf0  didMoveToView(view: \cf4 SKView\cf0 ) \{\
        \
        \cf2 // MARK: - Set Up Background\
\cf0         \cf3 self\cf0 .\cf4 backgroundColor\cf0  = \cf4 UIColor\cf0 .\cf7 whiteColor\cf0 ()\
        \
        \cf2 // MARK: - Set Up Constants\
\cf0         \cf3 self\cf0 .\cf5 Height\cf0  = \cf3 self\cf0 .\cf4 view\cf0 !.\cf4 frame\cf0 .\cf4 size\cf0 .\cf4 height\cf0 \
        \cf3 self\cf0 .\cf5 Width\cf0  = \cf3 self\cf0 .\cf4 view\cf0 !.\cf4 frame\cf0 .\cf4 size\cf0 .\cf4 width\cf0 \
        \cf3 self\cf0 .\cf5 xMid\cf0  = \cf3 self\cf0 .\cf4 view\cf0 !.\cf4 frame\cf0 .\cf4 midX\cf0 \
        \cf3 self\cf0 .\cf5 yMid\cf0  = \cf3 self\cf0 .\cf4 view\cf0 !.\cf4 frame\cf0 .\cf4 midY\cf0 \
        \cf3 self\cf0 .\cf5 xMax\cf0  = \cf5 xMid\cf0  + \cf5 Width\cf0 /\cf6 2\cf0 \
        \cf3 self\cf0 .\cf5 xMin\cf0  = \cf5 xMid\cf0  - \cf5 Width\cf0 /\cf6 2\cf0 \
        \cf3 self\cf0 .\cf5 yMax\cf0  = \cf5 yMid\cf0  + \cf5 Height\cf0 /\cf6 2\cf0 \
        \cf3 self\cf0 .\cf5 yMin\cf0  = \cf5 yMid\cf0  - \cf5 Height\cf0 /\cf6 2\cf0 \
        \cf3 self\cf0 .\cf5 Direction\cf0  = \cf8 "Left"\cf0 \
        \cf3 self\cf0 .\cf5 Circle\cf0  = \cf4 SKShapeNode\cf0 (circleOfRadius: \cf5 Width\cf0 /\cf6 30\cf0 )\
        \cf3 self\cf0 .\cf5 BlockHeight\cf0  = \cf4 CGFloat\cf0 (\cf4 Int\cf0 (\cf5 Height\cf0 /\cf6 30\cf0 )) + \cf4 CGFloat\cf0 (\cf4 Int\cf0 (\cf5 Height\cf0 /\cf6 30\cf0 ) % \cf6 2\cf0 )\
        \cf3 self\cf0 .\cf5 BlockWidth\cf0  = \cf4 CGFloat\cf0 (\cf4 Int\cf0 (\cf5 Width\cf0 /\cf6 30\cf0 )) + \cf4 CGFloat\cf0 (\cf4 Int\cf0 (\cf5 Width\cf0 /\cf6 30\cf0 ) % \cf6 2\cf0 )\
        \cf5 Circle\cf0 .\cf4 fillColor\cf0  = \cf4 UIColor\cf0 .\cf7 grayColor\cf0 ()\
        \cf5 Circle\cf0 .\cf4 alpha\cf0  = \cf6 0.5\cf0 \
        \cf5 TutorialInt\cf0  = \cf6 0\cf0 \
        \cf5 DirectionArray\cf0  = [\cf8 "Up"\cf0 ,\cf8 "Left"\cf0 ,\cf8 "Down"\cf0 ,\cf8 "Right"\cf0 ]\
        \cf5 LabelArray\cf0  = [\cf8 "Swipe to change the snake's direction."\cf0 ,\cf8 "The snake can move out of the boundaries."\cf0 ,\cf8 "Collect shining food blocks to grow the snake."\cf0 ,\cf8 "If the snake hits itself, you lose."\cf0 ,\cf8 "Double-tap the screen to pause the game."\cf0 ]\
        \cf5 NoFoodYet\cf0  = \cf3 true\cf0 \
        \cf5 ReadyToPlay\cf0  = \cf3 false\cf0 \
        \
        \cf2 // MARK: - Set Up Open Spaces\
\cf0         \cf3 for\cf0  x \cf3 in\cf0  \cf6 5\cf0 ...\cf4 Int\cf0 (\cf5 BlockWidth\cf0 -\cf6 1\cf0 ) \{\
            \cf3 for\cf0  y \cf3 in\cf0  \cf6 5\cf0 ...\cf4 Int\cf0 (\cf5 BlockHeight\cf0 -\cf6 1\cf0 ) \{\
                \cf5 OpenSpaces\cf0 .\cf7 append\cf0 (\cf4 CGPoint\cf0 (x:x, y:y))\
            \}\
        \}\
        \
        \cf2 // MARK: - Set Up GameBoard\
\cf0         \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x:\cf5 BlockWidth\cf0 /\cf6 2.0\cf0 ,y:\cf5 BlockHeight\cf0 /\cf6 2.0\cf0 ))\
        \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x:\cf5 BlockWidth\cf0 /\cf6 2.0\cf0  + \cf6 1\cf0 ,y:\cf5 BlockHeight\cf0 /\cf6 2.0\cf0 ))\
        \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x:\cf5 BlockWidth\cf0 /\cf6 2.0\cf0  + \cf6 2\cf0 ,y:\cf5 BlockHeight\cf0 /\cf6 2.0\cf0 ))\
        \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x:\cf5 BlockWidth\cf0 /\cf6 2.0\cf0  + \cf6 3\cf0 ,y:\cf5 BlockHeight\cf0 /\cf6 2.0\cf0 ))\
        \cf9 SpawnFood\cf0 ()\
        \
        \cf2 // MARK: - Set Up Circle\
\cf0         \cf9 StartMovementTutorial\cf0 ()\
        \
        \cf2 // MARK: - Set Up Quit\
\cf0         \
        \cf5 QuitButton\cf0  = \cf4 SKSpriteNode\cf0 (color: \cf4 UIColor\cf0 (white: \cf6 0.9\cf0 , alpha: \cf6 1.0\cf0 ), size: \cf4 CGSize\cf0 (width: \cf5 Width\cf0  * \cf6 0.12\cf0 , height: \cf5 Height\cf0  * \cf6 0.12\cf0 ))\
        \cf5 QuitButton\cf0 .\cf4 position\cf0  = \cf4 CGPoint\cf0 (x: \cf5 xMin\cf0  + \cf5 Width\cf0  * \cf6 0.01\cf0  + \cf5 QuitButton\cf0 .\cf4 size\cf0 .\cf4 width\cf0  / \cf6 2\cf0 , y: \cf5 yMax\cf0  - \cf5 Width\cf0  * \cf6 0.01\cf0  - \cf5 QuitButton\cf0 .\cf4 size\cf0 .\cf4 height\cf0  / \cf6 2\cf0 )\
        \cf5 QuitLabel\cf0  = \cf4 SKLabelNode\cf0 (text: \cf8 "Quit"\cf0 )\
        \cf5 QuitLabel\cf0 .\cf4 position\cf0  = \cf5 QuitButton\cf0 .\cf4 position\cf0 \
        \cf5 QuitLabel\cf0 .\cf4 fontSize\cf0  = \cf6 24\cf0 \
        \cf5 QuitLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
        \cf5 QuitLabel\cf0 .\cf4 verticalAlignmentMode\cf0  = \cf4 SKLabelVerticalAlignmentMode\cf0 .\cf7 Center\cf0 \
        \cf5 QuitLabel\cf0 .\cf4 zPosition\cf0  = \cf6 100\cf0 \
        \cf5 QuitButton\cf0 .\cf4 zPosition\cf0  = \cf6 99\cf0 \
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 QuitButton\cf0 )\
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 QuitLabel\cf0 )\
        \
        \cf2 // MARK: - SnakeTimer function\
\cf0         \cf5 SnakeTimer\cf0  = \cf4 NSTimer\cf0 .\cf7 scheduledTimerWithTimeInterval\cf0 (\cf6 0.2\cf0 , target: \cf3 self\cf0 , selector: \cf8 "MoveSnake"\cf0 , userInfo: \cf3 nil\cf0 , repeats: \cf3 true\cf0 )\
    \}\
    \
    \cf2 // MARK: - touches\
\cf0     \cf3 override\cf0  \cf3 func\cf0  touchesBegan(touches: \cf4 Set\cf0 <\cf4 UITouch\cf0 >, withEvent event: \cf4 UIEvent\cf0 ?) \{\
        \
        \cf3 if\cf0  \cf5 ReadyToPlay\cf0  \{\
            \cf3 for\cf0  touch \cf3 in\cf0  (touches ) \{\
                \cf3 let\cf0  location = touch.\cf7 locationInNode\cf0 (\cf3 self\cf0 )\
                \
                \cf3 if\cf0  (\cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 ) \{\
                    \cf2 // darken PlayAgainButton\
\cf0                     \cf5 PlayAgainButton\cf0 .\cf4 alpha\cf0  = \cf6 0.65\cf0 \
                    \cf5 PlayAgainLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 whiteColor\cf0 ()\
                \}\
                \cf3 else\cf0  \cf3 if\cf0  (\cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 ) \{\
                    \cf2 // darken MainMenuButton\
\cf0                     \cf5 MainMenuButton\cf0 .\cf4 alpha\cf0  = \cf6 0.65\cf0 \
                    \cf5 MainMenuLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 whiteColor\cf0 ()\
                \}\
            \}\
        \}\
        \cf3 else\cf0  \{\
            \cf3 for\cf0  touch \cf3 in\cf0  (touches ) \{\
                \cf3 let\cf0  location = touch.\cf7 locationInNode\cf0 (\cf3 self\cf0 )\
                \
                \cf3 if\cf0  (\cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 ) \{\
                    \cf2 // darken PlayAgainButton\
\cf0                     \cf5 QuitButton\cf0 .\cf4 color\cf0  = \cf4 UIColor\cf0 (white: \cf6 0.3\cf0 , alpha: \cf6 1.0\cf0 )\
                    \cf5 QuitLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 whiteColor\cf0 ()\
                    \cf5 QuitButtonClicked\cf0  = \cf3 true\cf0 \
                \}\
            \}\
        \}\
    \}\
    \
    \cf3 override\cf0  \cf3 func\cf0  touchesMoved(touches: \cf4 Set\cf0 <\cf4 UITouch\cf0 >, withEvent event: \cf4 UIEvent\cf0 ?) \{\
        \cf3 if\cf0  \cf5 ReadyToPlay\cf0  \{\
            \cf3 for\cf0  touch \cf3 in\cf0  (touches ) \{\
                \cf3 let\cf0  location = touch.\cf7 locationInNode\cf0 (\cf3 self\cf0 )\
                \
                \cf3 if\cf0  !(((\cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 )) || ((\cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 )))\{\
                    \
                    \cf2 // Lighten Both Buttons and Darken Both Labels\
\cf0                     \cf5 PlayAgainButton\cf0 .\cf4 alpha\cf0  = \cf6 0.15\cf0 \
                    \cf5 MainMenuButton\cf0 .\cf4 alpha\cf0  = \cf6 0.15\cf0 \
                    \cf5 PlayAgainLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
                    \cf5 MainMenuLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
                \}\
            \}\
        \}\
        \cf3 else\cf0  \{\
            \cf3 for\cf0  touch \cf3 in\cf0  (touches ) \{\
                \cf3 let\cf0  location = touch.\cf7 locationInNode\cf0 (\cf3 self\cf0 )\
                \
                \cf3 if\cf0  !(((\cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 )))\{\
                    \
                    \cf2 // Lighten Both Buttons and Darken Both Labels\
\cf0                     \cf5 QuitButton\cf0 .\cf4 color\cf0  = \cf4 UIColor\cf0 (white: \cf6 0.9\cf0 , alpha: \cf6 1.0\cf0 )\
                    \cf5 QuitLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
                    \cf5 QuitButtonClicked\cf0  = \cf3 false\cf0 \
                \}\
            \}\
        \}\
    \}\
    \
    \cf3 override\cf0  \cf3 func\cf0  touchesEnded(touches: \cf4 Set\cf0 <\cf4 UITouch\cf0 >, withEvent event: \cf4 UIEvent\cf0 ?) \{\
        \cf3 for\cf0  touch \cf3 in\cf0  (touches ) \{\
            \cf3 let\cf0  location = touch.\cf7 locationInNode\cf0 (\cf3 self\cf0 )\
            \cf3 if\cf0  \cf5 ReadyToPlay\cf0  \{\
                \cf3 if\cf0  (\cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 PlayAgainButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 ) && \cf7 abs\cf0 (\cf5 PlayAgainButton\cf0 .\cf4 alpha\cf0  - \cf6 0.65\cf0 ) <= \cf6 0.01\cf0  \{\
                    \cf9 PlayGame\cf0  ()\
                \}\
                \cf3 else\cf0  \cf3 if\cf0  (\cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 MainMenuButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 ) && \cf7 abs\cf0 (\cf5 MainMenuButton\cf0 .\cf4 alpha\cf0  - \cf6 0.65\cf0 ) <= \cf6 0.01\cf0  \{\
                    \cf9 OpenMainMenu\cf0  ()\
                \}\
                \cf3 else\cf0  \{\
                    \cf2 // Lighten Both Buttons and Darken Both Labels\
\cf0                     \cf5 PlayAgainButton\cf0 .\cf4 alpha\cf0  = \cf6 0.15\cf0 \
                    \cf5 MainMenuButton\cf0 .\cf4 alpha\cf0  = \cf6 0.15\cf0 \
                    \cf5 PlayAgainLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
                    \cf5 MainMenuLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
                \}\
            \}\
            \cf3 else\cf0  \{\
                \cf3 if\cf0  (\cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 minX\cf0  <= location.\cf4 x\cf0  && location.\cf4 x\cf0  <= \cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 maxX\cf0 ) && (\cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 minY\cf0  <= location.\cf4 y\cf0  && location.\cf4 y\cf0  <= \cf5 QuitButton\cf0 .\cf4 frame\cf0 .\cf4 maxY\cf0 ) && \cf5 QuitButtonClicked\cf0  \{\
                    \cf9 OpenMainMenu\cf0 ()\
                \}\
                \cf3 else\cf0  \{\
                    \cf5 QuitButton\cf0 .\cf4 color\cf0  = \cf4 UIColor\cf0 (white: \cf6 0.9\cf0 , alpha: \cf6 1.0\cf0 )\
                    \cf5 QuitLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
                    \cf5 QuitButtonClicked\cf0  = \cf3 false\cf0 \
                \}\
            \}\
        \}\
    \}\
\
    \
    \cf2 // MARK: - addBlock function\
\cf0     \cf3 func\cf0  addBlock (Position: \cf4 CGPoint\cf0 ) \{\
        \
        \cf3 for\cf0  block \cf3 in\cf0  \cf5 BlockArray\cf0  \{\
            block.\cf9 BlockNumChange\cf0 (block.\cf5 BlockNumber\cf0  + \cf6 1\cf0 , NewTotalBlocks: \cf4 CGFloat\cf0 (\cf5 BlockArray\cf0 .\cf4 count\cf0  + \cf6 1\cf0 ))\
            block.\cf4 size\cf0 .\cf4 width\cf0  = \cf5 Width\cf0  / \cf5 BlockWidth\cf0  - \cf6 2.0\cf0 \
            block.\cf4 size\cf0 .\cf4 height\cf0  = \cf5 Height\cf0  / \cf5 BlockHeight\cf0  - \cf6 2.0\cf0 \
        \}\
        \
        \cf3 let\cf0  x = Position.\cf4 x\cf0 \
        \cf3 let\cf0  y = Position.\cf4 y\cf0 \
        \
        \cf3 let\cf0  new_block = \cf5 Block\cf0 (Coordinate: \cf4 CGPoint\cf0 (x:x,y:y), BlockNum: \cf6 0\cf0 , TotalBlocks: \cf4 CGFloat\cf0 (\cf5 BlockArray\cf0 .\cf4 count\cf0  + \cf6 1\cf0 ))\
        new_block.\cf4 size\cf0 .\cf4 width\cf0  = \cf5 Width\cf0  / \cf5 BlockWidth\cf0  - \cf6 2.0\cf0 \
        new_block.\cf4 size\cf0 .\cf4 height\cf0  = \cf5 Height\cf0  / \cf5 BlockHeight\cf0  - \cf6 2.0\cf0 \
        \cf5 BlockArray\cf0 .\cf7 insert\cf0 (new_block, atIndex: \cf6 0\cf0 )\
        new_block.\cf4 position\cf0  = \cf9 GetBlocksRealPosition\cf0 (new_block.\cf5 Coordinates\cf0 )\
        \cf3 self\cf0 .\cf7 addChild\cf0 (new_block)\
    \}\
    \
    \cf2 // MARK: - removeBlock function\
\cf0     \cf3 func\cf0  removeBlock () \{\
        \cf3 let\cf0  last_block = \cf5 BlockArray\cf0 [\cf5 BlockArray\cf0 .\cf4 count\cf0  - \cf6 1\cf0 ]\
        last_block.\cf7 removeFromParent\cf0 ()\
        \cf5 BlockArray\cf0 .\cf7 removeLast\cf0 ()\
        \
        \cf3 for\cf0  block \cf3 in\cf0  \cf5 BlockArray\cf0  \{\
            block.\cf9 BlockNumChange\cf0 (block.\cf5 BlockNumber\cf0 , NewTotalBlocks: \cf4 CGFloat\cf0 (\cf5 BlockArray\cf0 .\cf4 count\cf0 ))\
        \}\
    \}\
    \
    \cf2 // MARK: - GetBlocksRealPosition function\
\cf0     \cf3 func\cf0  GetBlocksRealPosition (Position: \cf4 CGPoint\cf0 ) -> \cf4 CGPoint\cf0  \{\
        \
        \cf3 let\cf0  x = \cf4 CGFloat\cf0 (Position.\cf4 x\cf0 ) / \cf5 BlockWidth\cf0  * \cf5 Width\cf0  + \cf6 0.5\cf0  * \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf4 size\cf0 .\cf4 width\cf0  + \cf6 1.0\cf0  + \cf5 xMin\cf0 \
        \cf3 let\cf0  y = \cf4 CGFloat\cf0 (Position.\cf4 y\cf0 ) / \cf5 BlockHeight\cf0  * \cf5 Height\cf0  + \cf6 0.5\cf0  * \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf4 size\cf0 .\cf4 height\cf0  + \cf6 1.0\cf0  + \cf5 yMin\cf0 \
        \
        \cf3 let\cf0  RealPosition = \cf4 CGPoint\cf0 (x: x, y: y)\
        \
        \cf3 return\cf0  RealPosition\
    \}\
    \
    \cf2 // MARK: - MoveSnake function\
\cf0     \cf3 func\cf0  MoveSnake () \{\
        \cf3 if\cf0  \cf5 BlockArray\cf0 .\cf4 count\cf0  > \cf6 0\cf0  \{\
            \cf3 if\cf0  \cf5 Direction\cf0  == \cf8 "Left"\cf0  \{\
                \cf3 let\cf0  NewX = \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0  - \cf6 1\cf0 \
                \cf3 if\cf0  NewX == -\cf6 1\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf5 BlockWidth\cf0  - \cf6 1\cf0 , y: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0 ))\
                \}\
                \cf3 else\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: NewX, y: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0 ))\
                \}\
                \cf5 PreviousDirection\cf0  = \cf8 "Left"\cf0 \
            \}\
            \cf3 else\cf0  \cf3 if\cf0  \cf5 Direction\cf0  == \cf8 "Right"\cf0  \{\
                \cf3 let\cf0  NewX = \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0  + \cf6 1\cf0 \
                \cf3 if\cf0  NewX == \cf5 BlockWidth\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf6 0\cf0 , y: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0 ))\
                \}\
                \cf3 else\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: NewX, y: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0 ))\
                \}\
                \cf5 PreviousDirection\cf0  = \cf8 "Right"\cf0 \
            \}\
            \cf3 else\cf0  \cf3 if\cf0  \cf5 Direction\cf0  == \cf8 "Up"\cf0  \{\
                \cf3 let\cf0  NewY = \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0  + \cf6 1\cf0 \
                \cf3 if\cf0  NewY == \cf5 BlockHeight\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0 , y: \cf6 0\cf0 ))\
                \}\
                \cf3 else\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0 , y: NewY))\
                \}\
                \cf5 PreviousDirection\cf0  = \cf8 "Up"\cf0 \
            \}\
            \cf3 else\cf0  \{\
                \cf3 let\cf0  NewY = \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0  - \cf6 1\cf0 \
                \cf3 if\cf0  NewY == -\cf6 1\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0 , y: \cf5 BlockHeight\cf0  - \cf6 1\cf0 ))\
                \}\
                \cf3 else\cf0  \{\
                    \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0 , y: NewY))\
                \}\
                \cf5 PreviousDirection\cf0  = \cf8 "Down"\cf0 \
            \}\
            \
            \cf3 let\cf0  CollisionObject = \cf9 DetectCollision\cf0  ()\
            \
            \cf3 if\cf0  CollisionObject == \cf8 "tail"\cf0  \{\
                \cf9 removeBlock\cf0 ()\
            \}\
            \cf3 else\cf0  \cf3 if\cf0  CollisionObject == \cf8 "food"\cf0  \{\
                \cf9 removeBlock\cf0 ()\
                \cf9 addBlock\cf0 (\cf4 CGPoint\cf0 (x: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 x\cf0 ,y: \cf5 BlockArray\cf0 [\cf6 0\cf0 ].\cf5 Coordinates\cf0 .\cf4 y\cf0 ))\
                \cf5 FoodBlock\cf0 .\cf7 removeFromParent\cf0 ()\
                \
                \cf9 SpawnFood\cf0 ()\
            \}\
            \cf3 else\cf0  \{\
                \cf9 removeBlock\cf0 ()\
            \}\
            \
        \}\
    \}\
    \
    \cf2 // MARK: - DetectCollision function\
\cf0     \cf3 func\cf0  DetectCollision () -> \cf4 String\cf0  \{\
        \
        \cf3 let\cf0  head = \cf5 BlockArray\cf0 [\cf6 0\cf0 ]\
        \cf3 var\cf0  CollisionObject = \cf8 "none"\cf0 \
        \
        \cf3 for\cf0  block \cf3 in\cf0  \cf5 BlockArray\cf0  \{\
            \cf3 if\cf0  head != block && block != \cf5 BlockArray\cf0 .\cf4 last\cf0  && head.\cf5 Coordinates\cf0  == block.\cf5 Coordinates\cf0  \{\
                CollisionObject = \cf8 "tail"\cf0 \
            \}\
            \cf3 else\cf0  \cf3 if\cf0  head.\cf5 Coordinates\cf0  == \cf5 FoodBlock\cf0 .\cf5 Coordinates\cf0  \{\
                CollisionObject = \cf8 "food"\cf0 \
            \}\
        \}\
        \
        \cf3 return\cf0  CollisionObject\
    \}\
    \
    \cf2 // MARK: - SpawnFood function\
\cf0     \cf3 func\cf0  SpawnFood () \{\
        \
        \cf3 if\cf0  \cf5 NoFoodYet\cf0  \{\
            \cf5 FoodBlock\cf0 .\cf5 Coordinates\cf0  = \cf4 CGPoint\cf0 (x: \cf5 BlockWidth\cf0  - \cf6 4\cf0 , y: \cf5 BlockHeight\cf0  / \cf6 2\cf0 )\
        \}\
        \cf3 else\cf0  \{\
            \cf3 var\cf0  Taken = [\cf4 CGPoint\cf0 ]()\
            \
            \cf3 for\cf0  block \cf3 in\cf0  \cf5 BlockArray\cf0  \{\
                Taken.\cf7 append\cf0 (block.\cf5 Coordinates\cf0 )\
            \}\
            \
            \cf3 func\cf0  isNotTaken (coordinate: \cf4 CGPoint\cf0 ) -> \cf4 Bool\cf0  \{\
                \cf3 return\cf0  !\cf9 ListContains\cf0 (Taken, Element: coordinate)\
            \}\
            \
            \cf3 var\cf0  Open = \cf5 OpenSpaces\cf0 .\cf7 filter\cf0 (\cf9 isNotTaken\cf0 )\
            \
            \cf3 let\cf0  Rando = Open[\cf4 Int\cf0 (\cf7 arc4random_uniform\cf0 (\cf4 UInt32\cf0 (Open.\cf4 count\cf0  - \cf6 1\cf0 )))]\
            \
            \cf5 FoodBlock\cf0 .\cf5 Coordinates\cf0  = Rando\
        \}\
        \
        \cf5 NoFoodYet\cf0  = \cf3 false\cf0 \
        \
        \cf5 FoodBlock\cf0 .\cf4 position\cf0  = \cf9 GetBlocksRealPosition\cf0 (\cf5 FoodBlock\cf0 .\cf5 Coordinates\cf0 )\
        \cf5 FoodBlock\cf0 .\cf4 size\cf0 .\cf4 width\cf0  = \cf5 Width\cf0  / \cf5 BlockWidth\cf0  - \cf6 2.0\cf0 \
        \cf5 FoodBlock\cf0 .\cf4 size\cf0 .\cf4 height\cf0  = \cf5 Height\cf0  / \cf5 BlockHeight\cf0  - \cf6 2.0\cf0 \
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 FoodBlock\cf0 )\
    \}\
    \
    \cf3 func\cf0  StartMovementTutorial () \{\
        \
        \cf2 // Set Up Circle and Actions\
\cf0         \cf5 Circle\cf0 .\cf4 position\cf0  = \cf4 CGPoint\cf0 (x: \cf5 xMax\cf0  - \cf6 0.25\cf0  * \cf5 Width\cf0 , y: \cf5 yMin\cf0  + \cf6 0.25\cf0  * \cf5 Height\cf0 )\
        \cf5 Circle\cf0 .\cf4 alpha\cf0  = \cf6 0\cf0 \
        \cf3 let\cf0  Pause = \cf4 SKAction\cf0 .\cf7 scaleBy\cf0 (\cf6 1.0\cf0 , duration: \cf6 2.0\cf0 )\
        \cf3 let\cf0  FadeOut = \cf4 SKAction\cf0 .\cf7 fadeAlphaTo\cf0 (\cf6 0.0\cf0 , duration: \cf6 0.1\cf0 )\
        \cf3 let\cf0  FadeIn = \cf4 SKAction\cf0 .\cf7 fadeAlphaTo\cf0 (\cf6 1.0\cf0 , duration: \cf6 0.1\cf0 )\
        \
        \cf3 let\cf0  Up = \cf4 SKAction\cf0 .\cf7 moveBy\cf0 (\cf4 CGVector\cf0 (dx: \cf6 0\cf0 , dy: \cf6 0.5\cf0  * \cf5 Height\cf0 ), duration: \cf6 1.0\cf0 )\
        \cf3 let\cf0  Down = \cf4 SKAction\cf0 .\cf7 moveBy\cf0 (\cf4 CGVector\cf0 (dx: \cf6 0\cf0 , dy: -\cf6 0.5\cf0  * \cf5 Height\cf0 ), duration: \cf6 1.0\cf0 )\
        \cf3 let\cf0  Right = \cf4 SKAction\cf0 .\cf7 moveBy\cf0 (\cf4 CGVector\cf0 (dx: \cf6 0.5\cf0  * \cf5 Width\cf0 , dy: \cf6 0\cf0 ), duration: \cf6 1.0\cf0 )\
        \cf3 let\cf0  Left = \cf4 SKAction\cf0 .\cf7 moveBy\cf0 (\cf4 CGVector\cf0 (dx: -\cf6 0.5\cf0  * \cf5 Width\cf0 , dy: \cf6 0\cf0 ), duration: \cf6 1.0\cf0 )\
        \
        \cf3 let\cf0  UpAction = \cf4 SKAction\cf0 .\cf7 group\cf0 ([FadeIn,Up])\
        \cf3 let\cf0  DownAction = \cf4 SKAction\cf0 .\cf7 group\cf0 ([FadeIn,Down])\
        \cf3 let\cf0  LeftAction = \cf4 SKAction\cf0 .\cf7 group\cf0 ([FadeIn,Left])\
        \cf3 let\cf0  RightAction = \cf4 SKAction\cf0 .\cf7 group\cf0 ([FadeIn,Right])\
        \cf3 let\cf0  PauseAction = \cf4 SKAction\cf0 .\cf7 group\cf0 ([FadeOut,Pause])\
        \
        \cf2 // Add Circle\
\cf0         \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 Circle\cf0 )\
        \
        \cf2 // Add Actions\
\cf0         \cf3 let\cf0  Action = \cf4 SKAction\cf0 .\cf7 sequence\cf0 ([PauseAction,UpAction,PauseAction,LeftAction,PauseAction,DownAction,PauseAction,RightAction])\
        \cf3 let\cf0  RepeatedAction = \cf4 SKAction\cf0 .\cf7 repeatActionForever\cf0 (Action)\
        \cf5 Circle\cf0 .\cf7 runAction\cf0 (RepeatedAction)\
        \
        \cf9 MovementTutorialChangeDirection\cf0 ()\
        \cf9 WordsTutorial\cf0 ()\
    \}\
    \
    \cf3 func\cf0  MovementTutorialChangeDirection () \{\
        \
        \cf5 MoveMentTutorialTimer\cf0  = \cf4 NSTimer\cf0 .\cf7 scheduledTimerWithTimeInterval\cf0 (\cf6 3.0\cf0 , target: \cf3 self\cf0 , selector: \cf8 "MovementTutorialChangeDirectionFunction"\cf0 , userInfo: \cf3 nil\cf0 , repeats: \cf3 true\cf0 )\
    \}\
    \
    \cf3 func\cf0  MovementTutorialChangeDirectionFunction () \{\
        \
        \cf5 Direction\cf0  = \cf5 DirectionArray\cf0 [\cf5 TutorialInt\cf0 ]\
        \
        \cf5 TutorialInt\cf0  = (\cf5 TutorialInt\cf0  + \cf6 1\cf0 ) % \cf6 4\cf0 \
        \
    \}\
    \
    \cf3 func\cf0  WordsTutorial () \{\
        \
        \cf5 Label\cf0  = \cf4 SKLabelNode\cf0 (text: \cf8 ""\cf0 )\
        \cf5 Label\cf0 .\cf4 position\cf0  = \cf4 CGPoint\cf0 (x: \cf5 xMid\cf0 , y: \cf5 yMin\cf0  + \cf6 0.1\cf0  * \cf5 Height\cf0 )\
        \cf5 Label\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
        \cf5 Label\cf0 .\cf4 fontSize\cf0  = \cf5 Width\cf0  / \cf6 20\cf0 \
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 Label\cf0 )\
        \
        \cf9 WordsTutorialFunction\cf0 ()\
        \cf5 WordsTutorialTimer\cf0  = \cf4 NSTimer\cf0 .\cf7 scheduledTimerWithTimeInterval\cf0 (\cf6 5.0\cf0 , target: \cf3 self\cf0 , selector: \cf8 "WordsTutorialFunction"\cf0 , userInfo: \cf3 nil\cf0 , repeats: \cf3 true\cf0 )\
        \
    \}\
    \
    \cf3 func\cf0  WordsTutorialFunction () \{\
        \
        \cf3 if\cf0  \cf5 WordsInt\cf0  == \cf5 LabelArray\cf0 .\cf4 count\cf0  \{\
            \cf5 Label\cf0 .\cf4 text\cf0  = \cf8 ""\cf0 \
            \cf9 EndOfTutorial\cf0  ()\
        \}\
        \
        \cf3 else\cf0  \{\
            \cf3 let\cf0  words = \cf5 LabelArray\cf0 [\cf5 WordsInt\cf0 ]\
            \cf5 WordsInt\cf0  = \cf5 WordsInt\cf0  + \cf6 1\cf0 \
            \cf5 Label\cf0 .\cf4 text\cf0  = words\
        \}\
    \}\
    \
    \cf3 func\cf0  EndOfTutorial () \{\
        \
        \cf5 WordsTutorialTimer\cf0 .\cf7 invalidate\cf0 ()\
        \cf5 MoveMentTutorialTimer\cf0 .\cf7 invalidate\cf0 ()\
        \
        \cf5 QuitButton\cf0 .\cf7 removeFromParent\cf0 ()\
        \cf5 QuitLabel\cf0 .\cf7 removeFromParent\cf0 ()\
        \cf5 FoodBlock\cf0 .\cf7 removeFromParent\cf0 ()\
        \
        \cf2 // Set-Up and Display Title\
\cf0         \cf3 let\cf0  Title = \cf4 SKLabelNode\cf0 (text: \cf8 "Are you ready?"\cf0 )\
        Title.\cf4 position\cf0  = \cf4 CGPoint\cf0 (x: \cf5 Width\cf0  / \cf6 2\cf0 ,y: \cf6 4\cf0  * \cf5 Height\cf0  / \cf6 6\cf0 )\
        Title.\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
        Title.\cf4 fontSize\cf0  = \cf4 CGFloat\cf0 (\cf6 64\cf0 )\
        Title.\cf4 horizontalAlignmentMode\cf0  = \cf4 SKLabelHorizontalAlignmentMode\cf0 .\cf7 Center\cf0 \
        \cf3 self\cf0 .\cf7 addChild\cf0 (Title)\
        \
        \cf2 // Set-Up and Display MainMenuButton and PlayAgainButton\
\cf0         \cf5 MainMenuButton\cf0  = \cf4 SKSpriteNode\cf0 (color: \cf4 UIColor\cf0 .\cf7 blackColor\cf0 (), size: \cf4 CGSize\cf0 (width: \cf5 Width\cf0 /\cf6 4\cf0 , height: \cf5 Height\cf0 /\cf6 8\cf0 ))\
        \cf5 MainMenuButton\cf0 .\cf4 position\cf0  = \cf4 CGPoint\cf0 (x: \cf5 xMin\cf0  + \cf6 0.35\cf0 *\cf5 Width\cf0 , y: \cf5 yMin\cf0  + \cf6 0.4\cf0 *\cf5 Height\cf0 )\
        \cf5 MainMenuButton\cf0 .\cf4 alpha\cf0  = \cf4 CGFloat\cf0 (\cf6 0.15\cf0 )\
        \cf5 MainMenuLabel\cf0  = \cf4 SKLabelNode\cf0 (text: \cf8 "Main Menu"\cf0 )\
        \cf5 MainMenuLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
        \cf5 MainMenuLabel\cf0 .\cf4 fontSize\cf0  = \cf5 Width\cf0 /\cf6 20\cf0 \
        \cf5 MainMenuLabel\cf0 .\cf4 horizontalAlignmentMode\cf0  = \cf4 SKLabelHorizontalAlignmentMode\cf0 .\cf7 Center\cf0 \
        \cf5 MainMenuLabel\cf0 .\cf4 verticalAlignmentMode\cf0  = \cf4 SKLabelVerticalAlignmentMode\cf0 .\cf7 Center\cf0 \
        \cf5 MainMenuLabel\cf0 .\cf4 position\cf0  = \cf5 MainMenuButton\cf0 .\cf4 position\cf0 \
        \cf5 MainMenuLabel\cf0 .\cf4 zPosition\cf0  = \cf6 5\cf0 \
        \cf5 MainMenuButton\cf0 .\cf4 zPosition\cf0  = \cf6 4\cf0 \
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 MainMenuLabel\cf0 )\
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 MainMenuButton\cf0 )\
        \
        \cf5 PlayAgainButton\cf0  = \cf4 SKSpriteNode\cf0 (color: \cf4 UIColor\cf0 .\cf7 blackColor\cf0 (), size: \cf4 CGSize\cf0 (width: \cf5 Width\cf0 /\cf6 4\cf0 , height: \cf5 Height\cf0 /\cf6 8\cf0 ))\
        \cf5 PlayAgainButton\cf0 .\cf4 position\cf0  = \cf4 CGPoint\cf0 (x: \cf5 xMin\cf0  + \cf6 0.65\cf0 *\cf5 Width\cf0 , y: \cf5 yMin\cf0  + \cf6 0.4\cf0 *\cf5 Height\cf0 )\
        \cf5 PlayAgainButton\cf0 .\cf4 alpha\cf0  = \cf4 CGFloat\cf0 (\cf6 0.15\cf0 )\
        \cf5 PlayAgainLabel\cf0  = \cf4 SKLabelNode\cf0 (text: \cf8 "Play"\cf0 )\
        \cf5 PlayAgainLabel\cf0 .\cf4 fontColor\cf0  = \cf4 UIColor\cf0 .\cf7 blackColor\cf0 ()\
        \cf5 PlayAgainLabel\cf0 .\cf4 fontSize\cf0  = \cf5 Width\cf0 /\cf6 20\cf0 \
        \cf5 PlayAgainLabel\cf0 .\cf4 horizontalAlignmentMode\cf0  = \cf4 SKLabelHorizontalAlignmentMode\cf0 .\cf7 Center\cf0 \
        \cf5 PlayAgainLabel\cf0 .\cf4 verticalAlignmentMode\cf0  = \cf4 SKLabelVerticalAlignmentMode\cf0 .\cf7 Center\cf0 \
        \cf5 PlayAgainLabel\cf0 .\cf4 position\cf0  = \cf5 PlayAgainButton\cf0 .\cf4 position\cf0 \
        \cf5 PlayAgainLabel\cf0 .\cf4 zPosition\cf0  = \cf6 5\cf0 \
        \cf5 PlayAgainButton\cf0 .\cf4 zPosition\cf0  = \cf6 4\cf0 \
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 PlayAgainLabel\cf0 )\
        \cf3 self\cf0 .\cf7 addChild\cf0 (\cf5 PlayAgainButton\cf0 )\
        \
        \cf5 ReadyToPlay\cf0  = \cf3 true\cf0 \
        \
        \cf5 Circle\cf0 .\cf7 removeFromParent\cf0 ()\
        \
    \}\
    \
    \cf3 func\cf0  PlayGame () \{\
        \cf3 let\cf0  gameScene = \cf5 GameScene\cf0 (size: \cf3 self\cf0 .\cf4 size\cf0 )\
        \cf3 let\cf0  transition = \cf4 SKTransition\cf0 .\cf7 fadeWithColor\cf0 (\cf4 UIColor\cf0 .\cf7 whiteColor\cf0 (), duration: \cf6 1.0\cf0 )\
        gameScene.\cf4 scaleMode\cf0  = \cf4 SKSceneScaleMode\cf0 .\cf7 ResizeFill\cf0 \
        \cf3 self\cf0 .\cf4 scene\cf0 !.\cf4 view\cf0 ?.\cf7 presentScene\cf0 (gameScene, transition: transition)\
    \}\
    \
    \cf3 func\cf0  OpenMainMenu () \{\
        \cf3 let\cf0  mainMenuScene = \cf5 MainMenuScene\cf0 (size: \cf3 self\cf0 .\cf4 size\cf0 )\
        \cf3 let\cf0  transition = \cf4 SKTransition\cf0 .\cf7 fadeWithColor\cf0 (\cf4 UIColor\cf0 .\cf7 whiteColor\cf0 (), duration: \cf6 1.0\cf0 )\
        mainMenuScene.\cf4 scaleMode\cf0  = \cf4 SKSceneScaleMode\cf0 .\cf7 ResizeFill\cf0 \
        \cf3 self\cf0 .\cf4 scene\cf0 !.\cf4 view\cf0 ?.\cf7 presentScene\cf0 (mainMenuScene, transition: transition)\
    \}\
    \
    \cf2 // MARK: - update function\
\cf0     \cf3 override\cf0  \cf3 func\cf0  update(currentTime: \cf4 CFTimeInterval\cf0 ) \{\
        \cf2 /* Called before each frame is rendered */\cf0 \
    \}\
\}\
\
\cf2 // MARK: - ListContains function\
\cf3 func\cf0  ListContains (List: [\cf4 CGPoint\cf0 ], Element: \cf4 CGPoint\cf0 ) -> \cf4 Bool\cf0  \{\
    \cf3 var\cf0  boolean = \cf3 false\cf0 \
    \cf3 for\cf0  elt \cf3 in\cf0  List \{\
        \cf3 if\cf0  elt == Element \{\
            boolean = \cf3 true\cf0 \
        \}\
    \}\
    \cf3 return\cf0  boolean\
\}\
}